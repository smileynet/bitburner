import {display_minutes_and_seconds, get_array_from_file} from "utils.js";

/** 
 * @param {string} target_server The server to analyze for the next hacking step.
 * @returns {dictionary} job Returns job with server name, next action, threads needed, and time required. 
 */
export function analyze_target(ns, target_server) {
	ns.print(`Analyzing ${target_server}...`);

	var threads = 1; // For per unit calculation
	var cores = 1; // Not worries about cores right now

	var threads_needed = 0;
	var time_needed = 0;
	var task = "";

	var percent_to_steal = 0.40;
	
	var server_security_level = ns.getServerSecurityLevel(target_server)
	var server_min_security_level = ns.getServerMinSecurityLevel(target_server)
	var target_security_level = server_min_security_level + 5
	var server_max_money = ns.getServerMaxMoney(target_server)
	var server_money_available = ns.getServerMoneyAvailable(target_server)
	var server_growth_level = ns.getServerGrowth(target_server);

	ns.print(``);
	ns.print(`Current security level: ${ns.nFormat(server_security_level,'0,0.00')} desired security level: ${target_security_level}`);
	ns.print(`Current money level: \$${ns.nFormat(server_money_available,'0,0.00')} max money level: \$${ns.nFormat(server_max_money,'0,0.00')}`);
	ns.print(`Server growth factor: ${server_growth_level}`);
	ns.print(``);
	if (server_security_level > target_security_level) {
		ns.print(`Server weakening recommended.`)

		task = "weaken";
		time_needed = ns.getWeakenTime(target_server)	;
		var security_change_needed = server_security_level - server_min_security_level;
		var security_decrease = ns.weakenAnalyze(threads, cores);
		threads_needed = Math.ceil(security_change_needed / security_decrease);

		ns.print(`Amount to reduce security by: ${security_change_needed}, weaken threads needed: ${threads_needed} `);
		ns.print(`Time to execute weaken: ${display_minutes_and_seconds(time_needed)}`);

	} else if ( server_money_available < server_max_money ) {
		ns.print(`Server money growth recommended.`)
		
		task = "grow";
		var grow_amount = server_max_money - server_money_available;
		threads_needed = Math.ceil(ns.growthAnalyze(target_server, grow_amount, cores));
		security_increase = ns.growthAnalyzeSecurity(threads_needed);
		time_needed = ns.getGrowTime(target_server);

		ns.print(`Amount of money to grow: \$${ns.nFormat(grow_amount,'0,0.00')}, growth threads needed: ${threads_needed}`);
		ns.print(`Anticipated security increase from ${threads_needed} threads of growth: ${security_increase}`);
		ns.print(`Time to execute growth: ${display_minutes_and_seconds(time_needed)}`)
	} else {
		ns.print(`Server is ready for hacking.`)

		task = "hack";
		var hack_amount = server_money_available * percent_to_steal;
		var success_chance = ns.hackAnalyzeChance(target_server);
		threads_needed = Math.ceil(ns.hackAnalyzeThreads(target_server, hack_amount));
		var security_increase = ns.hackAnalyzeSecurity(threads_needed);
		time_needed = ns.getHackTime(target_server);

		ns.print(`Amount to steal: ${hack_amount}, threads needed: ${threads_needed}`);
		ns.print(`Chance of success: ${success_chance}`);
		ns.print(`Anticipated security increase: ${security_increase}`);
		ns.print(`Time to execute hack: ${display_minutes_and_seconds(time_needed)}`)		
	}
	ns.print(`-----------------------------------------------------------------------------`);

	var job = {'target': target_server, 'task': task, 'threads_needed': threads_needed, 'time_needed': time_needed, 'max_money': server_max_money, 'growth': server_growth_level};
	if (job['threads_needed'] == 0) {
		debugger;
		ns.tprint(`ERROR: Analyzer selected job with zero threads!`)
		ns.exit();
	}
	return job;
}

export async function main(ns) {
    if (ns.args[0]) {
        var target_servers = [ns.args[0]];
    } else {
        var target_servers = get_array_from_file(ns, "/data/hacking_targets.txt");
    }

	for (const target_server of target_servers) {
		await analyze_target(ns, target_server)
	}
}